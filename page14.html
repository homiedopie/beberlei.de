<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Blog of Benjamin Eberlei, covering a wide range of programming, bootstrapping and entrepreneurial topics">
        <meta name="viewport" content="width=device-width">
        <meta name="google-site-verification" content="mycr8JCbLYq9QcOyh4Ub1esAdN-awH9ut6nyTKUTgE4">
        <title>Page 14 &mdash; beberlei.de</title>
            <link rel="stylesheet" href="/_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="/_static/css/bootstrap.min.css" type="text/css" />
            <link rel="stylesheet" href="/_static/blog.css" type="text/css" />
            <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" />
        <link rel="shortcut icon" href="_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="search" title="Search" href="search.html" /><link rel="next" title="Older" href="page15.html" /><link rel="prev" title="Newer" href="page13.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.5.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script><script type="text/javascript" src="_static/disqus.js"></script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><nav class="navbar navbar-dark">
		  <div class="container">
			  <div class="navbar-header">
				  <a class="navbar-brand" href="https://beberlei.de">Benjamin Eberlei</a>
			  </div>

			  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
				  <ul class="nav navbar-nav navbar-right">
						<li><a href="index.html">Home</a></li>
						<li><a href="pages/about.html">About</a></li>
						<li><a href="/archive.html">Archive</a></li>
					  <li><a href="/rss.xml">RSS</a></li>
				  </ul>
			  </div>
		  </div>
		</nav><div class="main-container" role="main"><div class="container">
				<div class="row">
					<div class="col-md-8 col-md-offset-2 col-sm-12"><article role="article">
							<div class="section">
            <h1><a href="2009/01/23/zend-form-and-the-model-yet-another-perspective-using-a-mediator.html">Zend_Form and the Model: Yet another perspective using a Mediator</a></h1>
<p><a class="reference external" href="http://weierophinney.net/matthew/">Matthew Weier O’Phinney</a> of the
Zend Framework Devteam <a class="reference external" href="http://weierophinney.net/matthew/archives/200-Using-Zend_Form-in-Your-Models.html">wrote a controversial post on integrating
Zend_Form and the Model last
month</a>.
He separated concerns of view and model that communicate via a Form, by
calling just thee validation functions on the Form inside the mode. On
request you could retrieve the model to the controller and view layers.
I already wrote into his comments that I didn’t like the solution
because it relies on implicit rules for the developers to use the Form
component correctly in all layers. Additionally the building of the form
using this approach would be performed inside the model, although
strictly speaking this is responsibility of the View Layer. Another
negative point is duplication of input filtering code that has to be
performed to use certain variables inside the controller or when
different forms talk with the same model.</p>
<p><a class="reference external" href="http://codeutopia.net">Jani</a> took it up and <a class="reference external" href="http://codeutopia.net/blog/2009/01/07/another-idea-for-using-models-with-forms/">proposed writing
validators for forms and attaching them to the
Form</a>
as sort of a mediator. I am not a fan of this approach either, because
the validator would have to include domain logic but is not really a
part of the domain logic anymore but just a validator. Developers might
forget using the validator inside the model for all their actions or
there would be duplication of code in some places. In a perfect world,
only functions of the models public interface should be called for
validation.</p>
<p>My personal favorite for Form and Model integration is a <strong>mediator</strong>
object between the two layers. Your model will have to include an
additional interface with one function <strong>acceptFormRequest($values);</strong>
which accepts an array of validated Zend Form field values. It then
tries to apply the validated data into a record. Additional required
validations of the model can take place in this function, which
separates the concerns of Form validation and Model data validation.
Still the mediator merges those differences together: You can throw an
Exception and it will be attached as a custom error message to the Form.
The following very short code will show the required interface and the
mediator code. This code is very simple and might produce maintenance
overhead fast, but I propose some refactoring enhancements later in the
discussion.</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span/>interface WW_Model_AcceptFormRequest
{
    /**
     * Acceept a form request
     * @param array $values
     * @return WW_Record_Interface
     */
    public function acceptFormRequest($values);
}
class WW_Model_FormMediator
{
    /**
     * Try to push the form request to the model
     *
     * @param Zend_Form $form
     * @param WW_Model_AcceptFormRequest $model
     * @return WW_Record_Interface
     */
    public function pushFormToModel(Zend_Form $form, WW_Model_AcceptFormRequest $model)
    {
        if(!$form-&gt;isValid()) {
            throw new Exception("Form not valid!");
        } else {
            $values = $form-&gt;getValues();
            try {
                $record = $model-&gt;acceptFormRequest($values);
            } catch(Exception $e) {
                // This exception message comes from the model, because validation failed
                $form-&gt;addErrorMessage($e-&gt;getMessage());
                throw new Exception("Form request not accepted by model!");
            }
        }
        return $record;
    }
}
</pre></div>
</div>
</div></blockquote>
<p>You can see the mediator has two different stages where errors can
occur: When the form is not valid or the model is not valid. Both exits
can be catched inside the controller and are the indicator that the form
has to be displayed again for further input corrections. When successful
the model returns a valid record that applies to the form and model
requirements and can be displayed. If this record should be persistent
this would have been done inside the <strong>acceptFormRequest</strong> function
already. An example using a very simple Model using the a BankAccount
example. We have a form that validates all the incoming request data for
a withdrawal of money, though does not validate it against the models
internal state. Our BankAccountModel implements the
<strong>WW_Model_AcceptFormRequest</strong> interface and returns a valid
BankAccount. If found the given amount is withdrawn.</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span/>class BankAccountModel implements WW_Model_AcceptFormRequest {
    public function acceptFormRequest($values)
    {
        $bankAccount = $this-&gt;getBankAccountBy($values['bankAccountNumber'], $values['pin']);
        if($values['action'] == "withdraw") {
            $bankAccount-&gt;withdraw($values['amount']);
            $this-&gt;save($bankAccount);
        } else {
            // unknown action...
        }
    }
    public function getBankAccountBy($key, $password) {
        // Find by Primary Key returning 'BankAccount' instance or exception if not found.
    }
    public function save(BankAccount $ba) {
        // Sql for saving the Bank Account
    }
}

class BankAccount
{
    public function withdraw($amount)
    {
        if( ($this-&gt;getBalance()-$amount) &lt; 0 ) {
            throw new Exception("You cannot withdraw more money than your bank account holds!");
        }
        $this-&gt;balance -= $amount;
    }
}
</pre></div>
</div>
</div></blockquote>
<p>Two exceptions might be thrown in this case: The Bank Account number
does not exist or the password is wrong. Or you are not allowed to
withdraw the given amount of money. If any of those exceptions is thrown
the Model does not accept the form data and the form will have to be
displayed again for the client showing the new error message that was
returned from the model. The controller handling this process would look
like this:</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span/>class BankAccountController extends Zend_Controller_Action {
    public function performWithdrawlAction() {
        $form = new BankAccountWithdrawlForm(); // extends Zend_Form and builds the form

        if($this-&gt;getRequest()-&gt;isPost()) {
            $mediator         = new WW_Model_FormMediator();
            $bankAccountModel = new BankAccountModel();
            try {
                $bankAccount = $mediator-&gt;pushFormToModel($form, $bankAccountModel);

                $this-&gt;view-&gt;assign('bankAccount', $bankAccount); // Show new balance in view!
            } catch(Exception $e) {
                $this-&gt;view-&gt;assign('withdrawlForm', $form);
                $this-&gt;_redirect('showWithdrawl');
            }
        } else {
            $this-&gt;view-&gt;assign('withdrawlForm', $form);
            $this-&gt;_redirect('showWithdrawl');
        }
    }
}
</pre></div>
</div>
</div></blockquote>
<p>You can see the mediator tightly integrates Form and Model without both
components knowing too much of each other. Still you can add error
messages received from the model into the Form and redisplay it. One
negative point of this approach is the fact that you only have one
method for accepting form data, which could result in variable checking
and redispatching in the case of many different operations that can be
performed on the same model. For this case you might want to either:</p>
<ol class="arabic simple">
<li>Rewrite the mediator to accept a specific model class (not the
interface) and call the required custom method that matches the forms
request. (Best approach for separation concerns)</li>
<li>Rewrite the mediator to also pass the <strong>get_class($form);</strong> value to
the model for decision making (Faster approach)</li>
</ol>
<p>There is still some overhead on using the mediator. Since its generic
you could build an Action Helper for it and use the direct call
mechanism to save some lines of code.</p>


            
            <div class="tags">
                More about: 
                <a href="tags/zendframework.html">ZendFramework</a>
                
                
            </div>
            

            <div class="metadata">
        <p>
            <small>
                Posted on January 23, 2009
                
            </small>
        </p>
    </div>
        </div><div class="separator post_separator"></div><div class="section">
            <h1><a href="2009/01/14/finally-zend-mail-charset-and-or-long-lines-header-encoding-bug-fixed.html">Finally: Zend_Mail charset and/or long lines header encoding bug fixed</a></h1>
<p>There was this <a class="reference external" href="http://framework.zend.com/issues/browse/ZF-1688">lurking bug in
Zend_Mail</a> which
destroyed every Mail-Header (and corresponding Mail) with non US-ASCII
Chars and more than an encoded length of 74 chars. This is quite a huge
subset of mails, but it seems a nice solution was not so easy, at least
nobody tried to fixed it for quite some time.</p>
<p>Where many hackish solutions we’re offered, Ota Mares aka Littlex spent
incredible time to hunt the original problem down and with his help I
tag-teamed the bug to death today. Saturo Yoshida of Zend Fame added
some further spice regarding an alternative solution with Base64
Encoding instead of Quoted Printable Mime Header encoding.</p>
<p>In the end the solution we chose was, not to re-use the Mime encoding
function that is specific to MIME bodies according to
<a class="reference external" href="http://tools.ietf.org/html/rfc2045">RFC2045</a>, but to write a
completely new algorithm for Mime Headers, whose rules are specified in
<a class="reference external" href="http://tools.ietf.org/html/rfc2047">RFC2047</a>. This is now done and
unit-tests prove its working according to standard.</p>
<p>What is missing now is people trying that fix on as many Mail platforms
as possible and <a class="reference external" href="http://framework.zend.com/issues/browse/ZF-1688">giving feedback in the
issue</a> if a lengthy
subject with non-ASCII chars is displayed correctly.</p>


            
            <div class="tags">
                More about: 
                <a href="tags/zendframework.html">ZendFramework</a>
                
                
            </div>
            

            <div class="metadata">
        <p>
            <small>
                Posted on January 14, 2009
                
            </small>
        </p>
    </div>
        </div><div class="separator post_separator"></div><div class="section">
            <h1><a href="2009/01/11/howto-file-a-good-bug-report-suggestions-for-framework-users.html">Howto file a good bug report: Suggestions for framework users</a></h1>
<p>I have fixed quite a number of bugs for the ZF lately, which lead me to
this post about how to file a good bug report. There are many annoying
bug reports out there, where the reporter of the bug withholds important
information to the bugfixer unintended. This advice applies bug reports
in general of course.</p>
<p>What are the benefits of a good bug report? The bug generally gets fixed
faster, when the developer has more information at hand. Additionally
other developers might come to rescue since they can understand the
issue faster. These benefits are good for both parties. If you take no
time for a good bug report, your issue might risk to end up getting old
or closed unfixed.</p>
<ul class="simple">
<li><strong>Post the whole Exception Stack Trace</strong>: If the library throws an
Exception into your application that is unexpected and may indicate
an bug: Do not post the Message or Exception name only. The exception
may be thrown in many different places or due to different reasons.
The PHP exception class offers the method <strong>getTraceAsString()</strong>,
which offers many information to the developer what the cause of the
exception might be. Please use it!</li>
<li><strong>Post codefixes in a patch format</strong>: When you find a bug in the
framework, it is quite possible that you can offer a fix directly.
Writing “Replace x in line y with z” does not help very often. The
component might be in flux and the line positions change more often
than you think. Please create a diff file of this changes that
indicate the precise position of the change. This diff also includes
2 lines above and below the patched code for direction of the
developer. SVN Diffs are even more useful since they include the
revision where you fixed the bug in.</li>
<li><strong>Post reproducible cases as PHPUnit Test</strong>: If you find a bug and
can show how to reproduce it: Write a unittest to prove it. It is ZF
policy to create a unittest for each bugfix showing that the bug was
indeed fixed and previous functionality remains the same, so this
unit-test has to be written anyways. Many show-offs rely on massive
<strong>echo</strong> statements or <strong>var_dump</strong>, which render them almost
useless for the developer.</li>
<li><strong>Attach a unit-test to a submitted patch</strong>: This is related to the
previous point. If you add a unit test your patch will get more
attention. It will prove that you have thought about the patch, its
consequences and that you might have checked it does not break
backwards compatibility. This is worth a lot.</li>
<li><strong>Run the test suite with your patch</strong>: If you want to provide a
patch. Run the testsuite of the Zend Framework. It might break
expected behaviour. When you post a patch that will break BC, it will
be recognized. Your bug report might be closed, which helps nobody.</li>
</ul>
<p>When you find a bug you have probably thought about it and how to fix
it. This is valuable information. Disregarding one of this points will
lead to missing information on part of the developer that he has to
“learn” again. This takes time, which may make your bug last longer than
it should.</p>


            
            <div class="tags">
                More about: 
                <a href="tags/opensourcecitizen.html">OpenSourceCitizen</a>
                
                
            </div>
            

            <div class="metadata">
        <p>
            <small>
                Posted on January 11, 2009
                
            </small>
        </p>
    </div>
        </div><div class="separator post_separator"></div><div class="section">
            <h1><a href="2009/01/11/what-will-be-new-in-zf-1-8.html">What will be new in ZF 1.8</a></h1>
<p>In February or March 2009 the 1.8 version of the <a class="reference external" href="http://framework.zend.com">Zend
Framework</a> is scheduled to be released. I
have contributed some stuff already regarding ZendX_JQuery and
Zend_Soap.</p>
<p>Both components have seen numerous bugfixes and I managed to get the
JQuery helper down to zero open issues. I have also taken over the
<a class="reference external" href="http://framework.zend.com/wiki/display/ZFPROP/Zend_Json_Expr+to+allow+Javascript+Expressions+(functions)+to+be+encoded+using+Zend_Json">Zend_Json_Expr
proposal</a>,
which will be a huge benefit to everything JSON that can be done with
ZF. Foremost it is an integral part for the jQuery component which
heavily relies on javascript callbacks.</p>
<p>The Soap Autodiscover and WSDL classes compatibility with Java and .NET
has been optimized due to great user feedback, as well as some bugfixes
to the newly added WSDL type detection strategies.</p>
<p>Additionally I went on another bug killing spree and fixed around 20-30
old bugs in a wide range of different components.</p>


            
            <div class="tags">
                More about: 
                <a href="tags/zendframework.html">ZendFramework</a>
                
                
            </div>
            

            <div class="metadata">
        <p>
            <small>
                Posted on January 11, 2009
                
            </small>
        </p>
    </div>
        </div><div class="separator post_separator"></div><div class="section">
            <h1><a href="2009/01/12/on-publishing-webservices-within-mvc-frameworks.html">On Publishing Webservices within MVC Frameworks</a></h1>
<p>Webservices are a very important part in today’s enterprise applications.
They tie applications of different age or programming languages together
or allow applications of different subcontracters to speak to each
other. Because they use HTTP, a stateless network protocol, considerable
overhead floods the pipes when you use them, which should be minimized.</p>
<p><a class="reference external" href="http://martinfowler.com">Martin Fowler</a> writes in his <a class="reference external" href="http://martinfowler.com/eaaCatalog/">PEAA
book</a>, that if you have the
option not to use distributed objects (which are implemented via
webservice) you should not distribute them. Considerable effort has to
be brought into keeping complex webservices performant.</p>
<p>Still people make mistakes about webservices all the time (me included
for example proposing a dispatcher for the ZF that could be used for
webservices).</p>
<p>When people report problems with the Zend Soap component they often post
a stripped down example that involes their webservice being instantiated
within a controller. This is a very bad decision based on different
arguments:</p>
<ul class="simple">
<li><strong>Dispatching overhead</strong>: Dispatching, Routing, Pre- and
Postfiltering is costly in all frameworks. You give up the
performance of having numerous PHP scripts that act as controller on
their own. You get centralized filtering, authentication and other
benefits. But those benefits generally do not aply to XML, JSON or
SOAP requests, because you cannot parse them or access their
properties. You give up the performance of a page controller for
webservices to gain mostly nothing.</li>
<li><strong>HTTP Request uselessness</strong>: Web frameworks work with HTTP request
objects. The request of webservices facilitates HTTP to act as a far
more complex request. No framework I know off, allows to work with
the webservice requests outside the Webservice handler. What a SOAP
or XML-RPC request does in your MVC is only get passed through
numerous costly stages that offer no benefit, before it hits the
target. Only the parsing of HTTP-Headers might offer additional
benefit, but the gain is low, since they are available to PHP scripts
at no cost.</li>
<li><strong>Webservices already seperate concerns</strong>: Take the PHP SOAPServer as
an example. It is an MVC application on its own, the controlling
aspect of the SOAPServer parses the SOAP Request and sends it to the
model, a class given by the user, which in turn works and returns the
result as an SOAP Response View. You have to decouple model and view
for a webservice handler otherwise it would generate invalid
responses. Why nest a perfectly separated operation into another one?
You gain no more of this additional separation, except performance
decrease.</li>
</ul>
<p>So what are good practices to implement webservices?</p>
<ul class="simple">
<li>Use a page controller that generates no MVC overhead. In context of
the Zend Framework: Add a new php script to your web root and add a
new route into your .htaccess file that redirectes the desired
location of the webservice to the script that overwrites the standard
catch-all incoming requests to the front controller script.</li>
<li>Use the proxy pattern and the invaluable __call() method to
implement wrapper objects for authentication and session management
of the webservice. These classes can easily be reused by all
webservice page controllers of your site. If you do your homework you
can even share parts of these objects inside your Web-MVC application
to keep the code DRY. Those proxies keep authentication logic out of
your service class.</li>
<li>Use the remote facade pattern to implement a few, powerful methods
that delegate the service request to underlying domain objects. Never
ever publish direct access to domain objects with your webservices.
As a rule of thumb, talking to a webservice during a logical
operation should never involve more than one or two calls. The first
call is for data fetching, the second for data saving. Authentication
should be handled via HTTP Authentication to save an additional call.</li>
</ul>
<p>If you follow these simple rules, you should get around the performance
issues that generally come with webservices, without loosing flexibility
at all.</p>


            
            <div class="tags">
                More about: 
                <a href="tags/applicationdesign.html">ApplicationDesign</a>
                
                
            </div>
            

            <div class="metadata">
        <p>
            <small>
                Posted on January 12, 2009
                 by beberlei <kontakt@beberlei.de>
            </small>
        </p>
    </div>
        </div><div class="archive_link">
        <a href="archive.html">Archive</a>
    </div></article></div> <!-- #main -->
				</div>
			</div></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo">
			<div class="container">
				<div class="col-md-8 col-md-offset-2">
					<div class="footer">
						<small>© Copyright 2008-2017, Benjamin Eberlei.</small>

						<script type="text/javascript">    var disqus_shortname = "whitewashing";    disqus_count();</script>
					</div>
				</div>
			</div>
        </div> <!-- footer-container -->
      </div> <!--! end of #container --><script type="text/javascript">    var disqus_shortname = "whitewashing";    disqus_count();</script><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>